# -*- coding: utf-8 -*-
"""cell_tracking_btrack_challenge2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17Aurbp3JFfb4I0w9VngEddJxZ-V8DVU_

# Challenge 2 – Tracking individual cells with `btrack`

**Goal:** Track individual cells across ~20 frames from segmented microscopy images.

Pipeline:

1. Load segmented images (500 frames, `.tif`) from a ZIP archive.
2. Localize cells in each frame (label + region properties).
3. Run **btrack** to link cells across time.
4. Visualize tracks (optionally in **napari**).

> ⚠️ Note: napari is a desktop GUI viewer. The tracking itself works in Colab or Jupyter, but the napari viewer must be run in a local environment with a Qt event loop.
"""

# Optional: install dependencies (uncomment and run as needed)
# In Google Colab you might run:
# !pip install tifffile scikit-image matplotlib btrack napari[all]

import sys
import zipfile
from pathlib import Path

import numpy as np
import tifffile as tiff
from tifffile import TiffFileError

import matplotlib.pyplot as plt

from skimage.measure import label, regionprops_table
import pandas as pd

from skimage import exposure

# Detect if running in Google Colab
IN_COLAB = 'google.colab' in sys.modules
if IN_COLAB:
    from google.colab import files
    print("Running in Google Colab: using files.upload() for dynamic upload.")

# Optional: ipywidgets for classic Jupyter
try:
    import ipywidgets as widgets
    from IPython.display import display
    HAS_WIDGETS = True
except ImportError:
    HAS_WIDGETS = False
    print("ipywidgets not installed. Widget-based upload will not be available.")

"""## 1. Load segmented `.tif` images from a ZIP"""

def extract_zip(zip_path, extract_to="segmented_data"):
    """Extract the given ZIP file into a folder and return the folder path."""
    zip_path = Path(zip_path)
    extract_to = Path(extract_to)
    extract_to.mkdir(exist_ok=True)

    with zipfile.ZipFile(zip_path, "r") as zf:
        zf.extractall(extract_to)

    print(f"Extracted {zip_path} to {extract_to}")
    return extract_to


def load_tif_stack_from_folder(folder, max_frames=None):
    """Load a time-series stack from .tif files in a folder (and subfolders).

    - Uses ONLY real .tif images (ignores macOS junk like `__MACOSX` and `._*`).
    - Sorts frames by the numeric index in the filename if present.
    - Returns an array of shape (T, Y, X), dtype preserved.
    """
    folder = Path(folder)
    tif_files = [p for p in folder.rglob("*.tif") if "__MACOSX" not in p.parts and not p.name.startswith("._")]
    if not tif_files:
        raise FileNotFoundError(f"No .tif files found under {folder}")

    # Sort by numeric frame index if possible, else lexicographically
    import re
    def frame_key(p):
        m = re.search(r"(\d+)", p.name)
        return int(m.group(1)) if m else p.name
    tif_files = sorted(tif_files, key=frame_key)

    if max_frames is not None:
        tif_files = tif_files[:max_frames]

    print(f"Loading {len(tif_files)} frames from {folder} ...")
    frames = []
    for fp in tif_files:
        try:
            arr = tiff.imread(str(fp))
        except TiffFileError as e:
            print(f"Skipping invalid .tif file: {fp} -> {e}")
            continue

        if arr.ndim != 2:
            print(f"Skipping unexpected shape {arr.shape} in file {fp}")
            continue

        frames.append(arr)

    if not frames:
        raise RuntimeError("No valid 2D .tif frames were loaded.")

    stack = np.stack(frames, axis=0)  # (T, Y, X)
    print("Stack shape:", stack.shape, "dtype:", stack.dtype)
    return stack

# --- Choose / upload segmented_frames.zip ---

zip_path = None

if IN_COLAB:
    print("Please choose your segmented_frames.zip file (with .tif masks).")
    uploaded = files.upload()
    if len(uploaded) == 0:
        raise ValueError("No file uploaded. Please upload a ZIP file.")
    zip_name = list(uploaded.keys())[0]
    zip_path = Path(zip_name)
    print(f"Using uploaded ZIP: {zip_path}")
elif HAS_WIDGETS:
    print("If you see an upload widget below, use it to choose your .zip file, then re-run this cell.")
    try:
        uploader  # check if defined already
    except NameError:
        uploader = widgets.FileUpload(accept='.zip', multiple=False)
        display(uploader)
        raise ValueError("Upload a .zip file using the widget, then re-run this cell.")

    if len(uploader.value) == 0:
        display(uploader)
        raise ValueError("No file uploaded yet. Upload a .zip and re-run this cell.")
    else:
        name = list(uploader.value.keys())[0]
        content = uploader.value[name]["content"]
        zip_path = Path("segmented_frames.zip")
        with open(zip_path, "wb") as f:
            f.write(content)
        print(f"Saved uploaded ZIP to: {zip_path}")
else:
    # Fallback: assume the ZIP already exists in the working directory
    zip_path = Path("segmented_frames.zip")
    print(f"No dynamic upload available; using existing file: {zip_path}")
    if not zip_path.exists():
        raise FileNotFoundError(f"{zip_path} not found. Place segmented_frames.zip here or edit the path.")

# Extract and load segmentation stack
extract_folder = extract_zip(zip_path, extract_to="segmented_data")
# Load all frames, but we will track only a subset later
seg_stack = load_tif_stack_from_folder(extract_folder, max_frames=None)

# Normalize to [0,1] just for visualization; keep original for labeling
seg_stack_norm = seg_stack.astype(np.float32) / seg_stack.max()
print("Loaded segmentation stack with shape:", seg_stack.shape)

"""## 2. Inspect a few segmentation frames"""

# Show a few example frames
n_examples = 4
fig, axes = plt.subplots(1, n_examples, figsize=(4*n_examples, 4))
time_indices = np.linspace(0, seg_stack.shape[0]-1, n_examples, dtype=int)

for ax, t in zip(axes, time_indices):
    ax.imshow(seg_stack[t], cmap="gray")
    ax.set_title(f"Frame {t}")
    ax.axis("off")

plt.tight_layout()
plt.show()

"""## 3. Localize cells per frame using region properties"""

from skimage.measure import label, regionprops_table
import pandas as pd

# How many frames to actually track (for speed)?
N_FRAMES_TRACK = 20  # change to 100 or 500 as desired

seg_subset = seg_stack[:N_FRAMES_TRACK]

print(f"Using first {N_FRAMES_TRACK} frames for labeling and tracking.")

# Label each frame separately (binary -> labeled objects)
labels_stack = np.zeros_like(seg_subset, dtype=np.int32)
all_props = []

for t, frame in enumerate(seg_subset):
    lbl = label(frame > 0)  # connected components
    labels_stack[t] = lbl

    props = regionprops_table(
        lbl,
        properties=("label", "area", "centroid"),
    )
    props_df = pd.DataFrame(props)
    props_df["frame"] = t
    all_props.append(props_df)

props_df_all = pd.concat(all_props, ignore_index=True)
print(props_df_all.head())
print("\nTotal detections across frames:", len(props_df_all))

# Visualize labels over one frame
t_show = 0
fig, ax = plt.subplots(1, 1, figsize=(5, 5))
ax.imshow(seg_subset[t_show], cmap="gray")
ax.set_title(f"Labeled frame {t_show}")
ax.axis("off")
plt.show()

"""## 4. Track cells over time with `btrack`"""

import btrack
from btrack import datasets

# Convert labeled segmentation to btrack objects
# (segmentation_to_objects will internally use regionprops)
objects = btrack.utils.segmentation_to_objects(
    labels_stack, properties=("area",)
)
print(f"Number of objects passed to btrack: {len(objects)}")

# Use a pre-configured cell tracking model provided by btrack
config_file = datasets.cell_config()
print("Using btrack config file:", config_file)

# Define tracking volume (in pixels)
n_frames, height, width = labels_stack.shape
volume = ((0, height), (0, width))  # 2D (y,x) ranges

# You can also specify which features to use during tracking
FEATURES = ["area"]
TRACKING_UPDATES = ["motion"]  # or ["motion", "visual"]

with btrack.BayesianTracker() as tracker:
    # Configure tracker
    tracker.configure(config_file)

    # Features must be set before appending objects if you use 'visual' updates
    tracker.features = FEATURES

    # Append objects
    tracker.append(objects)

    # Set volume
    tracker.volume = volume

    # Run tracking
    print("Starting tracking...")
    tracker.track_interactive(step_size=100)

    # Optimize globally
    print("Optimizing tracks...")
    tracker.optimize()

    # Export in a format convenient for napari
    data, track_props, graph = tracker.to_napari(ndim=2)

print("Tracking complete.")
print("Tracks array shape (for napari):", data.shape)

"""## 5. Visualize tracks in napari (desktop)

The following cell opens a **napari** viewer with:

- A labels layer for the segmentation
- A tracks layer for the btrack output

> ⚠️ This requires running the notebook in a local environment with a working Qt backend  
> (e.g., local Jupyter, not pure Colab). In classic Jupyter, you may need to run `%gui qt` first.
"""

# Run this only in a local environment with GUI support
# (napari will not work in headless environments like pure Colab without extra setup)

try:
    import napari
except ImportError:
    print("napari is not installed in this environment. Install with `pip install napari[all]`.")
else:
    # If you're in classic Jupyter, uncomment the next line:
    # %gui qt

    viewer = napari.Viewer()
    viewer.add_labels(labels_stack, name="segmentation")
    viewer.add_tracks(data, properties=track_props, graph=graph, name="tracks")
    print("Napari viewer created. Interact with the viewer window.")